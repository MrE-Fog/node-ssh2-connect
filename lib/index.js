// Generated by CoffeeScript 2.6.1
var Client, camelize, constants, fs, path;

({
  constants,
  promises: fs
} = require('fs'));

path = require('path');

({Client} = require('ssh2'));

module.exports = function(options, callback) {
  var work;
  work = async function(resolve, reject) {
    var algo, connect, e, err, i, len, match, ref, retry, source;
    if (options instanceof Client) {
      return resolve(options);
    }
    options = camelize(options);
    if (options.username == null) {
      options.username = process.env['USER'] || require('child_process').execSync("whoami", {
        encoding: 'utf8',
        timeout: 1000
      }).trim();
    }
    if (options.username == null) {
      options.username = 'root'; // We've seed 'USER' not inside env inside the docker centos6 container.
    }
    if (options.retry == null) {
      options.retry = 1;
    }
    if (options.wait == null) {
      options.wait = 500;
    }
    if (!options.password && !options.privateKey) {
      if (options.privateKeyPath == null) {
        options.privateKeyPath = true; // Auto discovery
      }
    } else {
      options.privateKeyPath = null;
    }
    try {
      // Extract private key from file
      if (typeof options.privateKeyPath === 'string') {
        if (match = /~(\/.*)/.exec(options.privateKeyPath)) {
          options.privateKeyPath = path.join(process.env.HOME, match[1]);
        }
        options.privateKey = (await fs.readFile(options.privateKeyPath, 'ascii'));
      } else if (options.privateKeyPath === true) {
        ref = ['id_ed25519', 'id_rsa'];
        for (i = 0, len = ref.length; i < len; i++) {
          algo = ref[i];
          source = path.resolve(process.env.HOME, '.ssh', algo);
          try {
            options.privateKey = (await fs.readFile(source, 'ascii'));
            break;
          } catch (error) {
            err = error;
            ({});
          }
        }
        if (options.privateKey == null) {
          throw Error('Failed to discover an ssh private key inside `~/.ssh`.');
        }
      }
    } catch (error) {
      e = error;
      return reject(e);
    }
    // Connection attempts
    retry = options.retry;
    connect = function() {
      var connection, succeed;
      if (retry !== true && retry > 0) {
        retry--;
      }
      succeed = false;
      connection = new Client();
      connection.on('error', function(err) {
        connection.end();
        // Event "error" is thrown after a "ready" if the connection is lost
        if (succeed) {
          return;
        }
        if (retry === true || retry > 0) {
          return setTimeout(connect, options.wait);
        } else {
          return reject(err);
        }
      });
      connection.on('ready', function() {
        succeed = true;
        return resolve(connection);
      });
      return connection.connect(options);
    };
    return connect();
  };
  if (!callback) {
    return new Promise(work);
  } else {
    return work(function(conn) {
      return callback(null, conn);
    }, function(err) {
      return callback(err);
    });
  }
};

camelize = function(obj) {
  var k, newk, v;
  for (k in obj) {
    v = obj[k];
    newk = k.replace(/[_.-](\w|$)/g, function(_, x) {
      return x.toUpperCase();
    });
    if (k !== newk) {
      obj[newk] = v;
    }
  }
  return obj;
};

module.exports.is = function(instance) {
  return instance instanceof Client;
};
