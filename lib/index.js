// Generated by CoffeeScript 2.5.1
// # Connect

// This module provide a promise based api to open an ssh2 connection.

// For example, the original ssh2 code...   

// ```js
// const ssh2 = require('ssh2')
// const connection = new ssh2()
// connection.on('error', (err) => {
//   // not ready at all
//   connection.end()
// })
// connection.on('ready', () => {
//   // ready to go
// })
// connection.connect(options)
// ```

// ...is now simplified to:   

// ```js
// const connect = require('ssh2-exec')
// const ssh = await connect(options, (err, ssh) ->
//   // this is more comprehensive
// )
// ```
var camelize, fs, ssh2;

fs = require('fs').promises;

ssh2 = require('ssh2');

// Options are inherited from the [ssh2 `Connection.prototype.connect`][ssh2-connect]
// function with a few additions:

// -   `username`   
//     The username used to initiate the connection, default to the current
//     environment user.
// -   `privateKeyPath`   
//     Path to the file containing the private key.   
// -   `retry`
//     Attempt to reconnect multiple times, default to "1".   
// -   `wait`
//     Time to wait in milliseconds between each retry, default to "500".     

// Note, the "privateKeyPath" option is provided as a conveniency to  prepare the 
// "privateKey" property.

// Additionally, all options may be provided in camalize (the default in [ssh2]) or
// underscore form. For example, both "privateKey" and "private_key" would be
// interprated the same.
module.exports = function(options) {
  return new Promise(async function(resolve, reject) {
    var connect, e, match, retry;
    if (options instanceof ssh2) {
      return resolve(options);
    }
    options = camelize(options);
    if (options.username == null) {
      options.username = process.env['USER'] || require('child_process').execSync("whoami", {
        encoding: 'utf8',
        timeout: 1000
      }).trim();
    }
    if (options.username == null) {
      options.username = 'root'; // We've seed 'USER' not inside env inside the docker centos6 container.
    }
    if (options.retry == null) {
      options.retry = 1;
    }
    if (options.wait == null) {
      options.wait = 500;
    }
    if (!options.password && !options.privateKey) {
      if (options.privateKeyPath == null) {
        options.privateKeyPath = '~/.ssh/id_rsa';
      }
      if (options.privateKeyPath && (match = /~(\/.*)/.exec(options.privateKeyPath))) {
        options.privateKeyPath = process.env.HOME + match[1];
      }
    } else {
      options.privateKeyPath = null;
    }
    try {
      // Extract private key from file
      if (options.privateKeyPath) {
        options.privateKey = (await fs.readFile(options.privateKeyPath, 'ascii'));
      }
    } catch (error) {
      e = error;
      return reject(e);
    }
    // Connection attempts
    retry = options.retry;
    connect = function() {
      var connection, succeed;
      if (retry !== true && retry > 0) {
        retry--;
      }
      succeed = false;
      connection = new ssh2();
      connection.on('error', function(err) {
        connection.end();
        // Event "error" is thrown after a "ready" if the connection is lost
        if (succeed) {
          return;
        }
        if (retry === true || retry > 0) {
          return setTimeout(connect, options.wait);
        } else {
          return reject(err);
        }
      });
      connection.on('ready', function() {
        succeed = true;
        return resolve(connection);
      });
      return connection.connect(options);
    };
    return connect();
  });
};

camelize = function(obj) {
  var k, newk, v;
  for (k in obj) {
    v = obj[k];
    newk = k.replace(/[_.-](\w|$)/g, function(_, x) {
      return x.toUpperCase();
    });
    if (k !== newk) {
      obj[newk] = v;
    }
  }
  return obj;
};

// [ssh2]: https://github.com/mscdex/ssh2
// [ssh2-connect]: https://github.com/wdavidw/node-ssh2-connect
