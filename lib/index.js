// Generated by CoffeeScript 2.6.1
// # Connect

// This module provide a promise based api to open an ssh2 connection.

// For example, the original ssh2 code...   

// ```js
// const ssh2 = require('ssh2')
// const connection = new ssh2()
// connection.on('error', (err) => {
//   // not ready at all
//   connection.end()
// })
// connection.on('ready', () => {
//   // ready to go
// })
// connection.connect(options)
// ```

// ...is now simplified to:   

// ```js
// const connect = require('ssh2-exec')
// const ssh = await connect(options, (err, ssh) ->
//   // this is more comprehensive
// )
// ```
var Client, camelize, constants, fs, path;

({
  constants,
  promises: fs
} = require('fs'));

path = require('path');

({Client} = require('ssh2'));

// Options are inherited from the [ssh2 `Connection.prototype.connect`][ssh2-connect]
// function with a few additions:

// -   `username`   
//     The username used to initiate the connection, default to the current
//     environment user.
// -   `privateKeyPath`   
//     Path to the file containing the private key.   
// -   `retry`
//     Attempt to reconnect multiple times, default to "1".   
// -   `wait`
//     Time to wait in milliseconds between each retry, default to "500".     

// Note, the "privateKeyPath" option is provided as a conveniency to  prepare the 
// "privateKey" property.

// Additionally, all options may be provided in camalize (the default in [ssh2]) or
// underscore form. For example, both "privateKey" and "private_key" would be
// interprated the same.
module.exports = function(options, callback) {
  var work;
  work = async function(resolve, reject) {
    var algo, connect, e, err, i, len, match, ref, retry, source;
    if (options instanceof Client) {
      return resolve(options);
    }
    options = camelize(options);
    if (options.username == null) {
      options.username = process.env['USER'] || require('child_process').execSync("whoami", {
        encoding: 'utf8',
        timeout: 1000
      }).trim();
    }
    if (options.username == null) {
      options.username = 'root'; // We've seed 'USER' not inside env inside the docker centos6 container.
    }
    if (options.retry == null) {
      options.retry = 1;
    }
    if (options.wait == null) {
      options.wait = 500;
    }
    if (!options.password && !options.privateKey) {
      if (options.privateKeyPath == null) {
        options.privateKeyPath = true; // Auto discovery
      }
    } else {
      options.privateKeyPath = null;
    }
    try {
      // Extract private key from file
      if (typeof options.privateKeyPath === 'string') {
        if (match = /~(\/.*)/.exec(options.privateKeyPath)) {
          options.privateKeyPath = path.join(process.env.HOME, match[1]);
        }
        options.privateKey = (await fs.readFile(options.privateKeyPath, 'ascii'));
      } else if (options.privateKeyPath === true) {
        ref = ['id_ed25519', 'id_rsa'];
        for (i = 0, len = ref.length; i < len; i++) {
          algo = ref[i];
          source = path.resolve(process.env.HOME, '.ssh', algo);
          try {
            options.privateKey = (await fs.readFile(source, 'ascii'));
            break;
          } catch (error) {
            err = error;
            ({});
          }
        }
        if (options.privateKey == null) {
          throw Error('Failed to discover an ssh private key inside `~/.ssh`.');
        }
      }
    } catch (error) {
      e = error;
      return reject(e);
    }
    // Connection attempts
    retry = options.retry;
    connect = function() {
      var connection, succeed;
      if (retry !== true && retry > 0) {
        retry--;
      }
      succeed = false;
      connection = new Client();
      connection.on('error', function(err) {
        connection.end();
        // Event "error" is thrown after a "ready" if the connection is lost
        if (succeed) {
          return;
        }
        if (retry === true || retry > 0) {
          return setTimeout(connect, options.wait);
        } else {
          return reject(err);
        }
      });
      connection.on('ready', function() {
        succeed = true;
        return resolve(connection);
      });
      return connection.connect(options);
    };
    return connect();
  };
  if (!callback) {
    return new Promise(work);
  } else {
    return work(function(conn) {
      return callback(null, conn);
    }, function(err) {
      return callback(err);
    });
  }
};

camelize = function(obj) {
  var k, newk, v;
  for (k in obj) {
    v = obj[k];
    newk = k.replace(/[_.-](\w|$)/g, function(_, x) {
      return x.toUpperCase();
    });
    if (k !== newk) {
      obj[newk] = v;
    }
  }
  return obj;
};

// [ssh2]: https://github.com/mscdex/ssh2
// [ssh2-connect]: https://github.com/wdavidw/node-ssh2-connect
